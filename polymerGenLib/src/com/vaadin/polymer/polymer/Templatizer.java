/*
 * This code was generated with Vaadin Web Component GWT API Generator, 
 * from polymer project by The Polymer Authors (http://polymer.github.io/AUTHORS.txt)
 * that is licensed with http://polymer.github.io/LICENSE.txt license.
 */
package com.vaadin.polymer.polymer;

import com.vaadin.polymer.elemental.*;
import com.google.gwt.core.client.JavaScriptObject;
import com.google.gwt.core.client.JsArray;
import jsinterop.annotations.JsOverlay;
import jsinterop.annotations.JsProperty;
import jsinterop.annotations.JsType;


/**
 * <p>The <code>Polymer.Templatizer</code> behavior adds methods to generate instances of<br>templates that are each managed by an anonymous <code>Polymer.PropertyEffects</code><br>instance where data-bindings in the stamped template content are bound to<br>accessors on itself.</p>
 * <p>This behavior is provided in Polymer 2.x as a hybrid-element convenience<br>only.  For non-hybrid usage, the <code>Polymer.Templatize</code> library<br>should be used instead.</p>
 * <p>Example:</p>
 * <pre><code>// Get a template from somewhere, e.g. light DOM
 * let template = this.querySelector(&#39;template&#39;);
 * // Prepare the template
 * this.templatize(template);
 * // Instance the template with an initial data model
 * let instance = this.stamp({myProp: &#39;initial&#39;});
 * // Insert the instance&#39;s DOM somewhere, e.g. light DOM
 * Polymer.dom(this).appendChild(instance.root);
 * // Changing a property on the instance will propagate to bindings
 * // in the template
 * instance.myProp = &#39;new value&#39;;
 * 
 * 
 * </code></pre><p>Users of <code>Templatizer</code> may need to implement the following abstract<br>API’s to determine how properties and paths from the host should be<br>forwarded into to instances:</p>
 * <pre><code>_forwardHostPropV2: function(prop, value)
 * 
 * 
 * </code></pre><p>Likewise, users may implement these additional abstract API’s to determine<br>how instance-specific properties that change on the instance should be<br>forwarded out to the host, if necessary.</p>
 * <pre><code>_notifyInstancePropV2: function(inst, prop, value)
 * 
 * 
 * </code></pre><p>In order to determine which properties are instance-specific and require<br>custom notification via <code>_notifyInstanceProp</code>, define an <code>_instanceProps</code><br>object containing keys for each instance prop, for example:</p>
 * <pre><code>_instanceProps: {
 *   item: true,
 *   index: true
 * }
 * 
 * 
 * </code></pre><p>Any properties used in the template that are not defined in _instanceProp<br>will be forwarded out to the Templatize <code>owner</code> automatically.</p>
 * <p>Users may also implement the following abstract function to show or<br>hide any DOM generated using <code>stamp</code>:</p>
 * <pre><code>_showHideChildren: function(shouldHide)
 * 
 * 
 * </code></pre><p>Note that some callbacks are suffixed with <code>V2</code> in the Polymer 2.x behavior<br>as the implementations will need to differ from the callbacks required<br>by the 1.x Templatizer API due to changes in the <code>TemplateInstance</code> API<br>between versions 1.x and 2.x.</p>
 */
@JsType(isNative=true)
public interface Templatizer {

    @JsOverlay public static final String NAME = "Templatizer";
    @JsOverlay public static final String SRC = "polymer/polymer.html";



    /**
     * <p>Generates an anonymous <code>TemplateInstance</code> class (stored as <code>this.ctor</code>)<br>for the provided template.  This method should be called once per<br>template to prepare an element for stamping the template, followed<br>by <code>stamp</code> to create new instances of the template.</p>
     *
     * JavaScript Info:
     * @method templatize
     * @param {HTMLTemplateElement} template  
     * @param {boolean=} mutableData  
     * @behavior IronList
     * 
     */
    void templatize(JavaScriptObject template, boolean mutableData);

    /**
     * <p>Creates an instance of the template prepared by <code>templatize</code>.  The object<br>returned is an instance of the anonymous class generated by <code>templatize</code><br>whose <code>root</code> property is a document fragment containing newly cloned<br>template content, and which has property accessors corresponding to<br>properties referenced in template bindings.</p>
     *
     * JavaScript Info:
     * @method stamp
     * @param {Object=} model  
     * @behavior IronList
     * @return {JavaScriptObject}
     */
    JavaScriptObject stamp(JavaScriptObject model);

    /**
     * <p>Returns the template “model” (<code>TemplateInstance</code>) associated with<br>a given element, which serves as the binding scope for the template<br>instance the element is contained in.  A template model should be used<br>to manipulate data associated with this template instance.</p>
     *
     * JavaScript Info:
     * @method modelForElement
     * @param {HTMLElement} el  
     * @behavior IronList
     * @return {JavaScriptObject}
     */
    JavaScriptObject modelForElement(JavaScriptObject el);

}
